---
layout:     post
title:      "微服务客户端负载均衡器Ribbon实战"
subtitle:   " \"微服务客户端负载均衡器Ribbon实战\""
date:       2021-12-17 15:06:00 +0800
author:     "snowball"
header-img: "img/home-bg-o.jpg"
tags:
    - Spring Cloud
    - Ribbon
    - 负载均衡器
    - 微服务组件
typora-root-url: ..
---

<!--  “微服务组件-负载均衡器Ribbon实战. ” -->

### 主要内容

#### 1.Nacos整合Ribbon/Feign如何实现微服务调用

上一篇文章讲解了服务注册中心，主要功能是服务的注册与发现，这里介绍下微服务调用的过程

```
1.启动nacos-server，单机模式
2.引入nacos-discovery依赖(默认依赖ribbon)
3.application.yml配置服务注册中心地址，spring.cloud.nacos.discovery.server-addr
4.代码RestTemplate bean添加@LoadBalanced注解
5.远程调用restTemplate.getForObject("http://order-service/order/findOrderByUserId/", Resp.class),
6.也可以用open-feign进行远程接口方法调用，引入依赖spring-cloud-starter-openfeign，底层封装了ribbon
```

#### 2.微服务负载均衡器Ribbon

##### 2.1 什么是Ribbon

目前主流的负载方案分为以下两种：

- 集中式负载均衡，在消费者和服务提供方中间使用独立的代理方式进行负载，有硬件的（比如
  F5），也有软件的（比如 Nginx）。
- 客户端根据自己的请求情况做负载均衡，Ribbon 就属于客户端自己做负载均衡。

Spring Cloud Ribbon是基于Netflix Ribbon 实现的一套**客户端的负载均衡工具**，Ribbon客户端组件提供一系列的完善的配置，如超时，重试等。通过**Load Balancer**获取到服务提供的所有机器实例，Ribbon会自动基于某种规则(轮询，随机)去调用这些服务。Ribbon也可以实现我们自己的负载均衡算法。

##### 2.2 客户端的负载均衡

例如spring cloud中的ribbon，客户端会有一个服务器地址列表，在发送请求前通过负载均衡算法选择一个服务器，然后进行访问，这是客户端负载均衡；即在客户端就进行负载均衡算法分配。

![客户端的负载均衡1](/img/in-post/post-micro-service-ribbon/客户端的负载均衡1.png)

##### 2.2 服务端的负载均衡

例如Nginx，通过Nginx进行负载均衡，先发送请求，然后通过负载均衡算法，在多个服务器之间选择一个进行访问；即在服务器端再进行负载均衡算法分配。

![服务端的负载均衡](/img/in-post/post-micro-service-ribbon/服务端的负载均衡.png)

##### 2.3 常见负载均衡算法

- **随机**，通过随机选择服务进行执行，一般这种方式使用较少;
- **轮循**，负载均衡默认实现方式，请求来之后排队处理;
- **加权轮循**，通过对服务器性能的分型，给高配置，低负载的服务器分配更高的权重，均衡各个
  服务器的压力;
- **地址Hash**，通过客户端请求的地址的HASH值取模映射进行服务器调度。
- **最小链接数**，即使请求均衡了，压力不一定会均衡，最小连接数法就是根据服务器的情况，比
  如请求积压数等参数，将请求分配到当前压力最小的服务器上。

##### 2.4 Ribbon模块

| 名称                | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| ribbon-loadbalancer | 负载均衡模块，可独立使用，也可以和别的模块一起使用。         |
| ribbon              | 内置的负载均衡算法都实现在其中。                             |
| ribbon-eureka       | 基于 Eureka 封装的模块，能够快速、方便地集成 Eureka。        |
| ribbon-transport    | 基于 Netty 实现多协议的支持，比如 HTTP、Tcp、Udp 等。        |
| ribbon-httpclient   | 基于 Apache HttpClient 封装的 REST 客户端，集成了负载均衡模块，可以直接在项目中使用来调用接口。 |
| ribbon-example      | Ribbon 使用代码示例，通过这些示例能够让你的学习事半功倍。    |
| ribbon-core         | 一些比较核心且具有通用性的代码，客户端 API 的一些配置和其他 API 的定义。 |

##### 2.5 Ribbon使用

案例项目工程地址：https://gitee.com/snowball2dev/spring-cloud-alibaba-notice

参考工程user-service模块com.funny.user.RibbonDemo类，默认使用轮循负载均衡算法

```
// 服务列表
List<Server> serverList = Lists.newArrayList(new Server("localhost", 8081),
         new Server("localhost", 8082));

// 构建负载实例
ILoadBalancer loadBalancer = LoadBalancerBuilder.newBuilder()
        .buildFixedServerListLoadBalancer(serverList);

// 调用 5 次来测试效果
for (int i = 0; i < 5; i++) {
    String result = LoadBalancerCommand.<String>builder()
            .withLoadBalancer(loadBalancer).build()
            .submit(new ServerOperation<String>() {
                @Override
                public Observable<String> call(Server server) {
                	//省略xxx
                    return Observable.just(new String(""));
                }
            }).toBlocking().first();
    System.out.println(" 调用结果：" + result);
}
```

上述这个例子主要演示了 Ribbon 如何去做负载操作，调用接口用的最底层的 HttpURLConnection。

##### 2.6 Spring Cloud快速整合Ribbon

1.引入依赖

```
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
</dependency>
```

nacos-discovery依赖了ribbon，可以不用再引入ribbon依赖

2.添加@LoadBalanced注解

```
 @Bean
 @LoadBalanced
 public RestTemplate restTemplate(){
     RestTemplate restTemplate = new RestTemplate();
     return restTemplate;
 }
```

3.修改controller

```
 @RequestMapping(value = "/findOrderByUserId/{userId}")
 public Resp findOrderByUserId(@PathVariable String userId){
     logger.info("findOrderByUserId:{}", userId);
     //restTemplate调用
     String url = "http://order-service/order/findOrderByUserId/" + userId;
     Resp result = restTemplate.getForObject(url, Resp.class);

    //OpenFeign调用
    //Resp result = orderFeignApi.findOrderByUserId(userId);
    return result;
}
```

##### 2.7 Spring Cloud LoadBalancer

Spring Cloud LoadBalancer是Spring Cloud官方自己提供的客户端负载均衡器, 用来替代Ribbon。

Spring官方提供了两种负载均衡的客户端：

**RestTemplate**

RestTemplate是Spring提供的用于访问Rest服务的客户端，RestTemplate提供了多种便捷访问远程Http服务的方法，能够大大提高客户端的编写效率。默认情况下，RestTemplate默认依赖jdk的HTTP连接工具。

**WebClient**

WebClient是从Spring WebFlux 5.0版本开始提供的一个非阻塞的基于响应式编程的进行Http请求的客户端工具。它的响应式编程的基于Reactor的。WebClient中提供了标准Http请求方式对应的get、post、put、delete等方法，可以用来发起相应的请求。

**2.7.1.RestTemplate整合LoadBalancer**

引入依赖

```
<!-- LoadBalancer -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
</dependency>

<!‐‐ 提供了RestTemplate支持 ‐‐>
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-web</artifactId>
</dependency>

<dependency>
	<groupId>com.alibaba.cloud</groupId>
	<artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    <exclusions>
        <exclusion>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

修改yml

```
spring.cloud.loadbalancer.ribbon.enabled=false
```

添加@LoadBalanced注解

修改controller，和2.5内容一致



**2.7.2.WebClient整合LoadBalancer**

具体内容百度或联系笔者获取



#### 3.Ribbon调用原理分析

##### 3.1 Ribbon原理

![Ribbon原理](/img/in-post/post-micro-service-ribbon/Ribbon原理.png)



##### 3.2 模拟Ribbon实现

```
#restTemplate调用
String url = getUri("order-service") + "/order/findOrderByUserId/" + userId;
Resp result = restTemplate.getForObject(url, Resp.class);

@Autowired
DiscoveryClient discoveryClient;

private String getUri(String serviceId){
    List<ServiceInstance> instances = discoveryClient.getInstances(serviceId);
    if(CollectionUtils.isEmpty(instances)) return null;
    //轮询
    int serviceSize = instances.size();
    int indexServer = incrementAndGetModule(serviceSize);
    return instances.get(indexServer).getUri().toString();
}

private AtomicInteger nextIndex = new AtomicInteger(0);

private int incrementAndGetModule(int module) {
    for (; ; ) {
        int current = nextIndex.get();
        int next = (current + 1) % module;
        if (nextIndex.compareAndSet(current, next) && current < module) {
        return current;
        }
    }
}
```

##### 3.3 Ribbon相关接口

阅读源码应该多关注一些核心接口和扩展点，这样更快速掌握中间件核心机制

参考类：**org.springframework.cloud.netflix.ribbon.RibbonClientConfiguration**

**IClientConfig**：Ribbon的客户端配置，默认采用DefaultClientConfigImpl实现

**IRule**：Ribbon的负载均衡策略，默认采用**ZoneAvoidanceRule**实现，该策略能够在多区域环境下选出
最佳区域的实例进行访问。例如NacosRule。

**IPing**：Ribbon的实例检查策略，默认采用DummyPing实现，该检查策略是一个特殊的实现，实际上
它并不会检查实例是否可用，而是始终返回true，默认认为所有服务实例都是可用的。

**ServerList**：服务实例清单的维护机制，默认采用**ConfigurationBasedServerList**实现。例如NacosServerList。

**ServerListFilter**：服务实例清单过滤机制，默认采ZonePreferenceServerListFilter，该策略能够优先
过滤出与请求方处于同区域的服务实例。

**ILoadBalancer**：负载均衡器，默认采用**ZoneAwareLoadBalancer**实现，它具备了区域感知的能力。

![Ribbon的ILoadBalancer](/img/in-post/post-micro-service-ribbon/Ribbon的ILoadBalancer.png)

##### 3.4 Ribbon负载均衡策略

![Ribbon的IRule](/img/in-post/post-micro-service-ribbon/Ribbon的IRule.png)

**RandomRule**： 随机选择一个Server。

**RetryRule**： 对选定的负载均衡策略机上重试机制，在一个配置时间段内当选择Server不成功，则一直尝试使用subRule的方式选择一个可用的server。

**RoundRobinRule**： 轮询选择， 轮询index，选择index对应位置的Server。4. AvailabilityFilteringRule： 过滤掉一直连接失败的被标记为circuit tripped的后端Server，并过滤掉那些高并发的后端Server或者使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就是检查status里记录的各个Server的运行状态。

**BestAvailableRule**： 选择一个最小的并发请求的Server，逐个考察Server，如果Server被tripped了，则跳过。

**WeightedResponseTimeRule**： 根据响应时间加权，响应时间越长，权重越小，被选中的可能性越低。

**ZoneAvoidanceRule**： **默认的负载均衡策略**，即复合判断Server所在区域的性能和Server的可用性选Server，在没有区域的环境下，类似于轮询(RandomRule)

**NacosRule**: 同集群优先调用



#### 4.@LoadBalanced注解原理分析

参考源码： LoadBalancerAutoConfiguration

@LoadBalanced利用@Qualifier作为restTemplates注入的筛选条件，筛选出具有负载均衡标识RestTemplate。

```
public class LoadBalancerAutoConfiguration {

	@LoadBalanced
	@Autowired(required = false)
	private List<RestTemplate> restTemplates = Collections.emptyList();
	...
	
	static class LoadBalancerInterceptorConfig {
		@Bean
		public LoadBalancerInterceptor ribbonInterceptor(
				LoadBalancerClient loadBalancerClient,
				LoadBalancerRequestFactory requestFactory) {
			return new LoadBalancerInterceptor(loadBalancerClient, requestFactory);
		}
		
		@Bean
		@ConditionalOnMissingBean
		public RestTemplateCustomizer restTemplateCustomizer(
				final LoadBalancerInterceptor loadBalancerInterceptor) {
			return restTemplate -> {
				List<ClientHttpRequestInterceptor> list = new ArrayList<>(
						restTemplate.getInterceptors());
				list.add(loadBalancerInterceptor);
				restTemplate.setInterceptors(list);
			};
		}
	}
	...
}
```

被@LoadBalanced注解的restTemplate会被定制，添加LoadBalancerInterceptor拦截器。



#### 5.Ribbon负载均衡策略配置

**全局配置**：调用其他微服务，一律使用指定的负载均衡算法

```
@Configuration
public class RibbonConfig {

    /**
     * 全局配置,指定负载均衡策略
     *
     * @return
     */
    @Bean
    public IRule rule() {
        // 指定使用Nacos提供的负载均衡策略（优先调用同一集群的实例，基于随机权重）
        return new NacosRule();
    }
}
```

**局部配置**：调用指定微服务提供的服务时，使用对应的负载均衡算法

修改application.yml

```
# 被调用的微服务名
order-sevice:
  ribbon:
    # 指定使用Nacos提供的负载均衡策略（优先调用同一集群的实例，基于随机&权重）
    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule
```



#### 6.Ribbon自定义负载均衡策略

通过实现 IRule 接口可以自定义负载策略，主要的选择服务逻辑在 choose 方法中。

```
public class NacosRandomWithWeightRule extends AbstractLoadBalancerRule {
    private static final Logger logger = LoggerFactory.getLogger(NacosRandomWithWeightRule.class);

    @Autowired
    NacosDiscoveryProperties nacosDiscoveryProperties;

    @Override
    public void initWithNiwsConfig(IClientConfig config) {

    }

    @Override
    public Server choose(Object key) {
        DynamicServerListLoadBalancer loadBalancer = (DynamicServerListLoadBalancer) getLoadBalancer();

        String serviceName = loadBalancer.getName();
        NamingService namingService = nacosDiscoveryProperties.namingServiceInstance();
        //nacos基于权重的算法
        Instance instance = null;
        try {
            instance = namingService.selectOneHealthyInstance(serviceName);
            return new NacosServer(instance);
        } catch (NacosException e) {
            logger.error("获取服务实例异常:", e);
        }

        return null;
    }
}
```

思路：怎么实现不同版本的微服务实例不能直接调用？



##### 6.1.局部配置

修改application.yml

```
#被调用的微服务名
order-sevice:
  ribbon:
    NFLoadBalancerRuleClassName: com.funny.user.config.NacosRandomWithWeightRule
```

##### 2.全局配置

```
@Bean
public IRule rule2(){
	return new NacosRandomWithWeightRule();
}
```

##### 3.局部配置第二种方式

可以利用@RibbonClient指定微服务及其负载均衡策略。

```
@RibbonClients(value = {
 // 在SpringBoot主程序扫描的包外定义配置类
 @RibbonClient(name = "order-service",configuration = RibbonConfig.class),
 @RibbonClient(name = "account‐service",configuration = RibbonConfig.class)
})
public class UserApplication {
}
```

注意：此处有坑。不能写在@SpringbootApplication注解的@CompentScan扫描得到的地方，否则自定义的配置类就会被所有的 RibbonClients共享。 不建议这么使用，推荐yml方式

##### 4.饥饿加载

在进行服务调用的时候，如果网络情况不好，第一次调用会超时。Ribbon默认懒加载，意味着只有在发起调用的时候才会创建客户端。

开启饥饿加载，解决第一次调用慢的问题

```
ribbon:
  eager-load:
    enabled: true
    clients: user-service
```

源码对应属性配置类：RibbonEagerLoadProperties

