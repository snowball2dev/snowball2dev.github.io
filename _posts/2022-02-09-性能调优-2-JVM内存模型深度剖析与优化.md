---
layout:     post
title:      "JVM内存模型深度剖析与优化"
subtitle:   " \"JVM内存模型深度剖析与优化\""
date:       2022-02-09 16:45:00 +0800
author:     "snowball"
header-img: "img/home-bg.jpg"
tags:
    - JVM内存模型
    - JVM参数设置
    - VisualGC
typora-root-url: ..
---

<!--  “从JDK源码剖析JVM类加载机制. ” -->

### 主要内容

#### 1.JDK体系结构与跨平台特性介绍

##### 1.1 JDK体系结构

![JDK体系结构](/img/in-post/post-jvm-jmm/JDK体系结构.png)

JRE：Java(TM) SE Runtime Environment，Java运行时环境

以下着重讲解JVM相关内容

##### 1.2 Java语言的跨平台特性

![Java语言的跨平台特性](/img/in-post/post-jvm-jmm/Java语言的跨平台特性.png)

JVM底层特性使用C/C++实现，有兴趣可以阅读OpenJDK Hotspot源码

#### 2.JVM内存模型深度剖析

**JVM整体结构及内存模型**

![JVM整体结构及内存模型](/img/in-post/post-jvm-jmm/JVM整体结构及内存模型.png)



JVM主要分为类装载子系统、字节码执行引擎、运行时数据区域(内存模型)三部分

官方文档：https://docs.oracle.com/javase/specs/jvms/se8/html/index.html



**运行时数据区域**

线程共享

**堆**：对象区域，Eden(新生代 )、Survivor区(s0/s1)、老年代

**方法区**：常量、类元信息、静态变量等



线程不共享

**方法栈**：

运行时为每个线程都会分配一小块内存，栈，方法执行会进行压栈出栈，FILO先进后出。

每个方法运行时在栈内都保存有对应的栈帧，包含局部变量表、操作数栈、动态链接、方法出口等信息，要真正理解这些对应区域功能的对应含义，需要了解JVM底层字节码、字节码对应指令的运作机制，这里后面会写文章再介绍。

```
public class Math {
    public static final int initData = 666;
    public static User user = new User();

    public static void main(String[] args) {
        Math math = new Math();
        math.compute();
    }

    public int compute() { //一个方法对应一块栈帧内存区域
        int a = 1;
        int b = 2;
        int c = (a + b) * 10;
        return c;
    }

}

获取Class字节码可读内容
javap -c Math.class -> Math.txt

...
  public int compute();
    Code:
       0: iconst_1
       1: istore_1
       2: iconst_2
       3: istore_2
       4: iload_1
       5: iload_2
       6: iadd
       7: bipush        10
       9: imul
      10: istore_3
      11: iload_3
      12: ireturn
...
```

字节码指令文档可以参考[JVM指令手册](https://gitee.com/snowball2dev/java-advanced-content-notes/blob/master/1.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E9%A2%98/2.JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/00-JVM%E6%8C%87%E4%BB%A4%E6%89%8B%E5%86%8C.pdf)



**本地方法栈**：JNI方法栈

**程序计数器**：指令执行的行号等信息，线程被挂起后恢复可以继续从对应行号继续执行



#### 3.从jvisualvm来研究下对象内存流转模型

[VisualGC插件安装文档](https://gitee.com/snowball2dev/java-advanced-content-notes/blob/master/1.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%93%E9%A2%98/2.JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/jvisualvm%E5%AE%89%E8%A3%85Visual%20GC%E6%8F%92%E4%BB%B6.pdf)

```
public class HeapTest {
    byte[] data = new byte[1024 * 100]; //100kb

    public static void main(String[] args) throws InterruptedException {
        ArrayList<HeapTest> heapTests = new ArrayList<>();
        while (true){
            heapTests.add(new HeapTest());
            Thread.sleep(10);
        }
    }
}

运行结果：
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
	at com.funny.chapter2.HeapTest.<init>(HeapTest.java:9)
	at com.funny.chapter2.HeapTest.main(HeapTest.java:14)
```

VisualGC运行过程中截图：

![jvisualvm](.\jvisualvm.png)

整个区域分为三部分：**spaces、graphs、histogram**

1. **spaces区域**：代表虚拟机内存分布情况。从图中可以看出，虚拟机被分为Perm、Old、Eden、S0、S1

   **注意**：如果对每个区域基本概念不是很熟悉的可以先了解下java虚拟机运行时数据区相关文章。

   1.1）**perm**：英文叫做Permanent Generation，我们称之为永久代。(根据深入java虚拟机作者说明，这里说法不是不是很正确，因为hotspot虚拟机的设计团队选择把GC分代收集扩展至此而已，正确的应该叫做方法区或者非堆)。

   通过VM Args: 设置初始值与最大值

   ```
   -XX:PermSize=128m -XX:MaxPermSize=256m
   ```

   1.2）**heap**：java堆(java heap)。它包括老年代(图中Old区域)和新生代(图中Eden/S0/S1三个统称新生代，分为Eden区和两个Survivor区域)，他们默认是8:1:1分配内存，通过VM Args:

   ```
   -Xms512m -Xmx512m -XX:+HeapDumpOnOutofMemoryError -Xmn100m -XX:SurvivorRatio=8 
   ```

   设置初始堆内存、最大堆内存、内存异常打印dump、新生代内存、新生代内存分配比例(8:1:1)，因为Heap分为新生代跟老年代，所以512M-100M=412M，老年代就是412M(初始内存跟最大内存最好相等，防止内存不够时扩充内存或者Full GC，导致性能降低)

2. **Graphs区域**：内存使用详细介绍

   2.1）Compile Time(编译时间)：6368 compiles 表示编译总数，4.407s表示编译累计时间。一个脉冲表示一次JIT编译，窄脉冲表示持续时间短，宽脉冲表示持续时间长。
   2.2）Class Loader Time(类加载时间): 20869 loaded表示加载类数量, 139 unloaded表示卸载的类数量，40.630s表示类加载花费的时间
   2.3）GC Time(GC Time)：2392 collections表示垃圾收集的总次数，37.454s表示垃圾收集花费的时间，last cause表示最近垃圾收集的原因
   2.4）Eden Space(Eden 区)：括号内的31.500M表示最大容量，9.750M表示当前容量，后面的4.362M表示当前使用情况，2313collections表示垃圾收集次数，8.458s表示垃圾收集花费时间
   2.5）Survivor 0/Survivor 1(S0和S1区)：括号内的3.938M表示最大容量，1.188M表示当前容量，之后的值是当前使用情况
   2.6）Old Gen(老年代)：括号内的472.625M表示最大容量，145.031M表示当前容量，之后的87.031表示当前使用情况，79 collections表示垃圾收集次数 ，28.996s表示垃圾收集花费时间
   2.7）Perm Gen(永久代)：括号内的256.000M表示最大容量，105.250M表示当前容量，之后的105.032M表示当前使用情况

3. **Histogram区域**：survivor区域参数跟年龄柱状图

   3.1）Tenuring Threshold：表示新生代年龄大于当前值则进入老年代
   3.2）Max Tenuring Threshold：表示新生代最大年龄值。
   3.3）Tenuring Threshold与Max Tenuring Threshold区别：Max Tenuring Threshold是一个最大限定，所有的新生代年龄都不能超过当前值，而Tenuring Threshold是个动态计算出来的临时值，一般情况与Max Tenuring Threshold相等，如果在Suivivor空间中，相同年龄所有对象大小的总和大于Survivor空间的一半，则年龄大于或者等于该年龄的对象就都可以直接进入老年代(如果计算出来年龄段是5，则Tenuring Threshold=5，age>=5的Suivivor对象都符合要求)，它才是新生代是否进入老年代判断的依据。
   3.4）Desired Survivor Size：Survivor空间大小验证阙值(默认是survivor空间的一半)，用于Tenuring Threshold判断对象是否提前进入老年代。
   3.5）Current Survivor Size：当前survivor空间大小
   3.6）histogram柱状图：表示年龄段对象的存储柱状图
   3.7）如果显示指定-XX:+UseParallelGC --新生代并行、老年代串行收集器 ，则histogram柱状图不支持当前收集器



#### 4.讲透GC Root与STW机制

GC Roots的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象



方法区如何判断是否需要回收?

[参考文章](https://blog.csdn.net/qq_33366229/article/details/93194267)



#### 5.JVM参数设置通用模型

##### 5.1 JVM内存参数设置

![JVM内存参数设置](/img/in-post/post-jvm-jmm/JVM内存参数设置.png)

Spring Boot程序的JVM参数设置格式(Tomcat启动直接加在bin目录下catalina.sh文件里)：

```
java ‐Xms2048M ‐Xmx2048M ‐Xmn1024M ‐Xss512K ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐jar microservice‐server.jar
```

关于元空间的JVM参数有两个：-XX:MetaspaceSize=N和 -XX:MaxMetaspaceSize=N

**-XX：MaxMetaspaceSize**： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。

**-XX：MetaspaceSize**： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M，达到该值就会触发full gc进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过**-XX：MaxMetaspaceSize**（如果设置了的话） 的情况下， 适当提高该值。这个跟早期jdk版本的**-XX:PermSize**参数意思不一样，**-XX:PermSize**代表永久代的初始容量。

由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生了大小调整，基于这种情况，一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置成一样的值，并设置得比初始值要大，对于8G物理内存的机器来说，一般我会将这两个值都设置为256M。

StackOverflowError示例：

```
/**
 * JVM设置 ‐Xss128k(默认1M)
 */
public class StackOverflowTest {

    static int count = 0;

    static void redo() {
        count++;
        redo();
    }

    public static void main(String[] args) {
        try {
            redo();
        } catch (Throwable t) {
            t.printStackTrace();
            System.out.println(count);
        }
    }
}

运行结果：
java.lang.StackOverflowError
	at com.funny.chapter2.StackOverflowTest.redo(StackOverflowTest.java:11)
	...
1086
```

**结论：**
-Xss设置越小count值越小，说明一个线程栈里能分配的栈帧就越少，但是对JVM整体来说能开启的线程数会更多



##### 5.2 JVM内存参数大小该如何设置？

JVM参数大小设置并没有固定标准，需要根据实际项目情况分析，给大家举个例子



##### 5.3 日均百万级订单交易系统如何设置JVM参数

![如何设置JVM参数](/img/in-post/post-jvm-jmm/如何设置JVM参数.png)

**结论**：

通过上面这些内容介绍，大家应该对JVM优化有些概念了，就是尽可能让对象都在新生代里分配和回收，尽量别让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收，同时给系统充足的内存大小，避免新生代频繁的进行垃圾回收。

